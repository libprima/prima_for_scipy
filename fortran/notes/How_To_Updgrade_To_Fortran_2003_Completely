In 2020, Fortran 2003 features are still not completely supported by
compilers. Therefore, the Fortran code of this project keeps some pre-2003
features. They can be removed later (say, in 2025) if compilers implement
Fortran 2003 better at that time.

The pre-2003 features include the following.

1. Fixed-length character array.

For example,

integer, parameter :: MSGLEN = 200
character(len = MSGLEN) :: msg
msg = 'ABC'
print *, trim(msg)

In Fortran 2003, this can be replaced by

character(len=:), allocatable :: msg
msg = 'ABC'  ! Automatic allocation upon intrinsic assignment.
print *, msg

HOW TO FIND: search for 'character' or 'character(len' or 'len = ',
and also 'trim('.

Up to Absoft 22.0, af95 does not support allocatable strings.


2. Related to 1, we do not take advantage of the "automatic allocation
upon intrinsic assignment" feature for ALLOCATABLE variables (NOT
POINTERS).

For example,

real, allocatable :: x(:)

call safealloc(x, n)
x = y  ! y is an array of size n

can be replaced by

real, allocatable :: x(:)

x = y ! Automatic allocation upon intrinsic assignment

HOW TO FIND: search for 'safealloc' and 'fmxAlloc'

N.B.: Not all allocation can be removed!
1. Automatic allocation does not happen for POINTERs.
2. Another example:

real, allocatable :: x(:)
integer :: n

allocate(x(n))
do i = 1, n
    x(i) = real(i)
end do

However, the above example can be simplified to the following without ALLOCATE using implicit loop:

real, allocatable :: x(:)
x = [(real(i), i = 1, n)]

3. Related to 2: explicit deallocation v.s. automatic deallocation (maybe we should stick to the former)
In F2003, automatic deallocation happens to allocatable objects when they go out of scope. However,
we prefer to deallocate them explicitly and immediately after they finish their mission. In
addition, as of 20220331, automatic deallocate may not be well implemented in some compilers
including (even) gfortran. See
https://fortran-lang.discourse.group/t/best-practice-deallocating-allocatable-arrays-explicitly-vs-implicitly
